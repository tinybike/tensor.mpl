
with(LinearAlgebra);
normalizeColumns := proc (A::Matrix, type := 1) local nRows, nColumns, column, normalizedA; nRows, nColumns := Dimensions(A); normalizedA := Matrix(nRows, nColumns); for column to nColumns do if type = 1 then normalizedA[1 .. -1, column] := A[1 .. -1, column]/add(A[1 .. -1, column]) else normalizedA[1 .. -1, column] := Normalize(A[1 .. -1, column], type) end if end do; return normalizedA end proc;
get4thOrderTensorDimensions := proc (A::Array) local n; n := Vector(4); n[1] := ArrayNumElems(A[1, 1, 1]); n[2] := ArrayNumElems(A[1, 1])/n[1]; n[3] := ArrayNumElems(A[1])/(n[1]*n[2]); n[4] := ArrayNumElems(A)/(n[1]*n[2]*n[3]); return n end proc;
get4thOrderTensorElement := proc (A::Array, ii, jj, kk, ll) return A[ll, kk, jj, ii] end proc;
set4thOrderTensorElement := proc (A::Array, value, ii, jj, kk, ll) A[ll, kk, jj, ii] := value; return A end proc;
get4thOrderTensorFace := proc (A::Array, fiber3, fiber4) local ii, jj, kk, ll, n, tensorFace; n := get4thOrderTensorDimensions(A); tensorFace := Matrix(n[1], n[2]); for ii to n[1] do for jj to n[2] do tensorFace[ii, jj] := get4thOrderTensorElement(A, ii, jj, fiber3, fiber4) end do end do; return tensorFace end proc;
print4thOrderTensorFaces := proc (A::Array) local ii, jj, kk, ll, n; n := get4thOrderTensorDimensions(A); for ii to n[4] do for jj to n[3] do print([jj, ii] = get4thOrderTensorFace(A, jj, ii)) end do end do end proc;
multiply4thOrderTensors := proc (A::Array, B::Array, rowOrColumn) local AB, ii, jj, kk, ll, n; n := get4thOrderTensorDimensions(A); AB := create4thOrderTensor(n[1], n[2], n[3], n[4], fill = empty); for ii to n[1] do for jj to n[2] do for kk to n[3] do for ll to n[4] do if rowOrColumn = column then set4thOrderTensorElement(AB, simplify(add(get4thOrderTensorElement(A, ii, jj, m, ll)*get4thOrderTensorElement(B, m, jj, kk, ll), m = 1 .. n[3])+add(get4thOrderTensorElement(A, ii, jj, kk, m)*get4thOrderTensorElement(B, ii, m, kk, ll), m = 1 .. n[4])), ii, jj, kk, ll) else set4thOrderTensorElement(AB, simplify(add(get4thOrderTensorElement(A, ii, m, kk, ll)*get4thOrderTensorElement(B, m, jj, kk, ll), m = 1 .. n[2])+add(get4thOrderTensorElement(A, ii, jj, kk, m)*get4thOrderTensorElement(B, ii, jj, m, ll), m = 1 .. n[4])), ii, jj, kk, ll) end if end do end do end do end do; return AB end proc;
create4thOrderTensor := proc (n1::integer, n2::integer, n3::integer, n4::integer, { fill := index, fdiagonalIndex := 12 }) local A, ii, jj, kk, ll; A := Array(1 .. n4, 1 .. n3, 1 .. n2, 1 .. n1); if fill = empty then return A end if; for ii to n1 do for jj to n2 do for kk to n3 do for ll to n4 do if fill = index then set4thOrderTensorElement(A, a[cat(ii, jj, kk, ll)], ii, jj, kk, ll) elif fill = identity then if ii = jj and ii = kk and ii = ll then set4thOrderTensorElement(A, 1, ii, jj, kk, ll) else set4thOrderTensorElement(A, 0, ii, jj, kk, ll) end if elif fill = diagonal then if ii = jj and ii = kk and ii = ll then set4thOrderTensorElement(A, a[cat(ii, jj, kk, ll)], ii, jj, kk, ll) else set4thOrderTensorElement(A, 0, ii, jj, kk, ll) end if elif fill = fdiagonal then if fdiagonalIndex = 12 and ii = jj or fdiagonalIndex = 23 and jj = kk or fdiagonalIndex = 34 and kk = ll or fdiagonalIndex = 13 and ii = kk or fdiagonalIndex = 24 and jj = ll or fdiagonalIndex = 14 and ii = ll then set4thOrderTensorElement(A, a[cat(ii, jj, kk, ll)], ii, jj, kk, ll) else set4thOrderTensorElement(A, 0, ii, jj, kk, ll) end if else set4thOrderTensorElement(A, fill, ii, jj, kk, ll) end if end do end do end do end do; return A end proc;
get3rdOrderTensorDimensions := proc (A::Array) local n; n := Vector(3); n[1] := ArrayNumElems(A[1, 1]); n[2] := ArrayNumElems(A[1])/n[1]; n[3] := ArrayNumElems(A)/(n[1]*n[2]); return n end proc;
get3rdOrderTensorElement := proc (A::Array, ii, jj, kk) return A[kk, jj, ii] end proc;
set3rdOrderTensorElement := proc (A::Array, value, ii, jj, kk) A[kk, jj, ii] := value; return A end proc;
get3rdOrderTensorStackedFace := proc (A::Array, fiber1) local ii, jj, n, tensorFace; n := get3rdOrderTensorDimensions(A); tensorFace := Matrix(n[1], n[2]); for ii to n[1] do for jj to n[2] do tensorFace[ii, jj] := get3rdOrderTensorElement(A, fiber1, ii, jj) end do end do; return tensorFace end proc;
get3rdOrderTensorVerticalFace := proc (A::Array, fiber2) local ii, jj, n, tensorFace; n := get3rdOrderTensorDimensions(A); tensorFace := Matrix(n[1], n[2]); for ii to n[1] do for jj to n[2] do tensorFace[ii, jj] := get3rdOrderTensorElement(A, ii, fiber2, jj) end do end do; return tensorFace end proc;
get3rdOrderTensorFace := proc (A::Array, fiber3) local ii, jj, n, tensorFace; n := get3rdOrderTensorDimensions(A); tensorFace := Matrix(n[1], n[2]); for ii to n[1] do for jj to n[2] do tensorFace[ii, jj] := get3rdOrderTensorElement(A, ii, jj, fiber3) end do end do; return tensorFace end proc;
print3rdOrderTensorFaces := proc (A::Array, { axis::integer := 1 }) local ii, jj, kk, ll, n; n := get3rdOrderTensorDimensions(A); for ii to n[3] do if axis = 1 then print([ii] = get3rdOrderTensorFace(A, ii)) elif axis = 2 then print([ii] = get3rdOrderTensorStackedFace(A, ii)) elif axis = 3 then print([ii] = get3rdOrderTensorVerticalFace(A, ii)) end if end do end proc;
multiply3rdOrderTensors := proc (A::Array, B::Array, rowOrColumn) local AB, ii, jj, kk, n, ll; n := get3rdOrderTensorDimensions(A); AB := create4thOrderTensor(n[1], n[2], n[3], n[3], fill = empty); for ii to n[1] do for jj to n[2] do for kk to n[3] do for ll to n[3] do if rowOrColumn = column then set4thOrderTensorElement(AB, add(get3rdOrderTensorElement(A, ii, jj, m)*get3rdOrderTensorElement(B, m, jj, ll), m = 1 .. n[3]), ii, jj, kk, ll) else set4thOrderTensorElement(AB, add(get3rdOrderTensorElement(A, ii, m, kk)*get3rdOrderTensorElement(B, m, jj, ll), m = 1 .. n[2]), ii, jj, kk, ll) end if end do end do end do end do; return AB end proc;
multiply4thOrderTensorWithVector := proc (A::Array, x::Vector, { axis::integer := 2 }) local Ax, ii, jj, kk, ll, n, vectorLength; n := get4thOrderTensorDimensions(A); vectorLength := Dimensions(x); if n[axis] <> vectorLength then return false end if; if axis = 1 then Ax := create3rdOrderTensor(n[2], n[3], n[4], fill = empty) elif axis = 2 then Ax := create3rdOrderTensor(n[1], n[3], n[4], fill = empty) elif axis = 3 then Ax := create3rdOrderTensor(n[1], n[2], n[4], fill = empty) elif axis = 4 then Ax := create3rdOrderTensor(n[1], n[2], n[3], fill = empty) end if; for ii to n[1] do for jj to n[2] do for kk to n[3] do for ll to n[4] do if axis = 4 then set3rdOrderTensorElement(Ax, add(get4thOrderTensorElement(A, ii, jj, kk, m)*x[m], m = 1 .. vectorLength), ii, jj, kk) elif axis = 3 then set3rdOrderTensorElement(Ax, add(get4thOrderTensorElement(A, ii, jj, m, ll)*x[m], m = 1 .. vectorLength), ii, jj, ll) elif axis = 2 then set3rdOrderTensorElement(Ax, add(get4thOrderTensorElement(A, ii, m, kk, ll)*x[m], m = 1 .. vectorLength), ii, kk, ll) elif axis = 1 then set3rdOrderTensorElement(Ax, add(get4thOrderTensorElement(A, m, jj, kk, ll)*x[m], m = 1 .. vectorLength), jj, kk, ll) end if end do end do end do end do; return Ax end proc;
multiply3rdOrderTensorWithVector := proc (A::Array, x::Vector, { axis::integer := 2 }) local Ax, ii, jj, kk, n, vectorLength; n := get3rdOrderTensorDimensions(A); vectorLength := Dimensions(x); if n[axis] <> vectorLength then return false end if; if axis = 1 then Ax := Matrix(n[2], n[3]) elif axis = 2 then Ax := Matrix(n[1], n[3]) elif axis = 3 then Ax := Matrix(n[1], n[2]) end if; for ii to n[1] do for jj to n[2] do for kk to n[3] do if axis = 3 then Ax[ii, jj] := add(get3rdOrderTensorElement(A, ii, jj, m)*x[m], m = 1 .. vectorLength) elif axis = 2 then Ax[ii, kk] := add(get3rdOrderTensorElement(A, ii, m, kk)*x[m], m = 1 .. vectorLength) elif axis = 1 then Ax[jj, kk] := add(get3rdOrderTensorElement(A, m, jj, kk)*x[m], m = 1 .. vectorLength) end if end do end do end do; return Ax end proc;
create3rdOrderTensor := proc (n1::integer, n2::integer, n3::integer, { fill := index, fdiagonalIndex := 12, indexFillSymbol := a, faces := 0 }) local A, ii, jj, kk; A := Array(1 .. n3, 1 .. n2, 1 .. n1); if fill = empty then return A end if; for ii to n1 do for jj to n2 do for kk to n3 do if fill = index then set3rdOrderTensorElement(A, indexFillSymbol[parse(cat(ii, jj, kk))], ii, jj, kk) elif fill = identity then if ii = jj and ii = kk then set3rdOrderTensorElement(A, 1, ii, jj, kk) else set3rdOrderTensorElement(A, 0, ii, jj, kk) end if elif fill = diagonal then if ii = jj and ii = kk then set3rdOrderTensorElement(A, indexFillSymbol[parse(cat(ii, jj, kk))], ii, jj, kk) else set3rdOrderTensorElement(A, 0, ii, jj, kk) end if elif fill = fdiagonal then if fdiagonalIndex = 12 and ii = jj or fdiagonalIndex = 23 and jj = kk or fdiagonalIndex = 13 and ii = kk then set3rdOrderTensorElement(A, indexFillSymbol[parse(cat(ii, jj, kk))], ii, jj, kk) else set3rdOrderTensorElement(A, 0, ii, jj, kk) end if elif fill = matrix then set3rdOrderTensorElement(A, faces[kk][ii, jj], ii, jj, kk) else set3rdOrderTensorElement(A, fill, ii, jj, kk) end if end do end do end do; return A end proc;
copyMatrix := proc (A::Matrix) local ii, jj, n, copyOfA; n := Dimensions(A); copyOfA := Matrix(n[1], n[2]); for ii to n[1] do for jj to n[2] do copyOfA[ii, jj] := A[ii, jj] end do end do; return copyOfA end proc;
kroneckerPower := proc (A::Matrix, power::integer) local ii, n, poweredA; poweredA := copyMatrix(A); for ii to power-1 do poweredA := KroneckerProduct(poweredA, A) end do; return poweredA end proc;
evolveUsingKroneckerPowers := proc (A::Matrix, Aprime::Matrix, tau::integer, initialStateParticle1::Vector, initialStateParticle2::Vector) local k, AprimeKronA, productOfAprimeKronAPowers, vKronPowerU; AprimeKronA := KroneckerProduct(Aprime, A); productOfAprimeKronAPowers := copyMatrix(AprimeKronA); for k from 2 to tau-1 do productOfAprimeKronAPowers := productOfAprimeKronAPowers . kroneckerPower(AprimeKronA, 2^(k-1)) end do; vKronPowerU := kroneckerPower(KroneckerProduct(initialStateParticle2, initialStateParticle1), 2^(tau-1)); productOfAprimeKronAPowers := productOfAprimeKronAPowers . vKronPowerU; return A . productOfAprimeKronAPowers, Aprime . productOfAprimeKronAPowers end proc;
evolveUsingRecurrence := proc (G::Array, tau::integer, initialStateParticle1::Vector, initialStateParticle2::Vector) local t, u1__1, u1__2, v1__1, v1__2, sigma__111, sigma__121, sigma__211, sigma__221, sigma__112, sigma__122, sigma__212, sigma__222, u0__1, u0__2, v0__1, v0__2; sigma__111 := get3rdOrderTensorElement(G, 1, 1, 1); sigma__121 := get3rdOrderTensorElement(G, 1, 2, 1); sigma__211 := get3rdOrderTensorElement(G, 2, 1, 1); sigma__221 := get3rdOrderTensorElement(G, 2, 2, 1); sigma__112 := get3rdOrderTensorElement(G, 1, 1, 2); sigma__122 := get3rdOrderTensorElement(G, 1, 2, 2); sigma__212 := get3rdOrderTensorElement(G, 2, 1, 2); sigma__222 := get3rdOrderTensorElement(G, 2, 2, 2); u0__1 := initialStateParticle1[1]; u0__2 := initialStateParticle1[2]; v0__1 := initialStateParticle2[1]; v0__2 := initialStateParticle2[2]; for t to tau do u1__1 := (sigma__111*u0__1+sigma__121*u0__2)*v0__1+(sigma__112*u0__1+sigma__122*u0__2)*v0__2; u1__2 := (sigma__211*u0__1+sigma__221*u0__2)*v0__1+(sigma__212*u0__1+sigma__222*u0__2)*v0__2; v1__1 := (sigma__111*v0__1+sigma__121*v0__2)*u0__1+(sigma__112*v0__1+sigma__122*v0__2)*u0__2; v1__2 := (sigma__211*v0__1+sigma__221*v0__2)*u0__1+(sigma__212*v0__1+sigma__222*v0__2)*u0__2; u0__1 := u1__1; u0__2 := u1__2; v0__1 := v1__1; v0__2 := v1__2 end do; return Vector([u1__1, u1__2]), Vector([v1__1, v1__2]) end proc;
















